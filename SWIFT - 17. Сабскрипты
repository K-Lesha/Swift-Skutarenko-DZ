

// MARK: SUBSCRIPT

/// –ª—ë–≥–∫–∏–π —É—Ä–æ–≤–µ–Ω—å: —à–∞—Ö–º–∞—Ç–Ω–∞—è –¥–æ—Å–∫–∞, —Å–æ–∑–¥–∞—Ç—å —Ç–∏–ø —à–∞—Ö–º–∞—Ç–Ω–∞—è –¥–æ—Å–∫–∞, –∞-h ‚Äî —Å—Ç–æ–ª–±—Ü—ã, 1-8 —Ä—è–¥—ã
/// –∫–æ–≥–¥–∞ –æ–±—Ä–∞—â–∞—é—Å—å –ø–æ —Å–∞–±—Å–∫—Ä–∏–ø—Ç—É (–≥–µ—Ç—Ç–µ—Ä) –∫ —è—á–µ–π–∫–µ ‚Äî –≤–µ—Ä–Ω—É—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –±–µ–ª—ã–π / —á–µ—Ä–Ω—ã–π(—ç–Ω—É–º)
/// –µ—Å–ª–∏ —è –≤—ã–±–∏—Ä–∞—é —Ü–∏—Ñ—Ä—É –∏–ª–∏ –±—É–∫–≤—É –∑–∞ –¥–∏–∞–ø–∞–∑–æ–Ω–æ–º, —Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –Ω–∏–ª


struct ChessPlate {
    
    func getKey (column: String, raw: Int) -> String {
        return column + String(raw)
    }
    
    var dict : [String: String] = [:]
    
    subscript (column: String, raw: Int) -> String? {
        get {
            var intLetter = 0
            
            if raw > 8 {
                print("not correct coordinates")
                return nil
            }
            
            switch column {
            case "a": intLetter = 1
            case "b": intLetter = 2
            case "c": intLetter = 3
            case "d": intLetter = 4
            case "e": intLetter = 5
            case "f": intLetter = 6
            case "g": intLetter = 7
            case "h": intLetter = 8
            default:
                print("not correct coordinates")
                return nil
            }
            return ((intLetter % 2) == (raw % 2)) ? "‚¨õ" : "‚¨ú"
        }
        set {
            dict[getKey(column: column, raw: raw)] = self[column, raw]
        }
    }
}


var chessPlate = ChessPlate()
let letters = ["a", "b", "c", "d" ,"e", "f", "g", "h"]
for letter in letters {
    for number in 1...8 {
        chessPlate[letter, number] = ""
    }
}




///—Å—Ä–µ–¥–Ω–∏–π —É—Ä–æ–≤–µ–Ω—å: –∏–≥—Ä–∞ –∫—Ä–µ—Å—Ç–∏–∫–∏-–Ω–æ–ª–∏–∫–∏
///—Å–æ–∑–¥–∞—Ç—å –ø–æ–ª–µ 3—Ö3, —Å–æ–∑–¥–∞—Ç—å —ç–Ω—É–º ‚Äî –ª–∏–±–æ –ø—É—Å—Ç–æ, –ª–∏–±–æ –∫—Ä–µ—Å—Ç–∏–∫, –ª–∏–±–æ 0
///–∫–∞–∂–¥–∞—è —è—á–µ–π–∫–∞ –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ –ø—É—Å—Ç–æ, –∫—Ä–µ—Å—Ç–∏–∫, –Ω–æ–ª–∏–∫
///–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∫—Ä–∞—Å–∏–≤–æ —Ä–∞—Å–ø–µ—á–∞—Ç–∞—Ç—å –ø–æ–ª–µ
///–ø–æ —Å–∞–±—Å–∫—Ä–∏–ø—Ç—É –æ–±—Ä–∞—â–∞—Ç—å—Å—è –∫ —è—á–µ–π–∫–µ ‚Äî¬†—Ü–∏—Ñ—Ä–∞ –∏ —Ü–∏—Ñ—Ä–∞
///–∏ —Å—Ç–∞–≤–∏—Ç—å —Ç—É–¥–∞ –∫–∞–∫–æ–µ-—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ (–ª–∏–±–æ –∫—Ä–µ—Å—Ç–∏–∫, –ª–∏–±–æ –Ω–æ–ª–∏–∫
///—Å–¥–µ–ª–∞—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É, –µ—Å–ª–∏ –≤—ã–±–∏—Ä–∞—é —Ä—è–¥ –∏–ª–∏ —Å—Ç–æ–ª–±–µ—Ü, –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —Ç–æ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞—é
///–Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å—Ç–∞–≤–∏—Ç—å –ø—É—Å—Ç–æ –≤ –ø–æ–ª–µ
///
///–µ—Å–ª–∏ —è —Å—Ç–∞–≤–ª—é –∫—Ä–µ—Å—Ç–∏–∫, –≥–¥–µ —É–∂–µ —Å—Ç–æ–∏—Ç –Ω–æ–ª–∏–∫, —Ç–æ –Ω–µ–ª—å–∑—è, –¥–∞—Ç—å –æ—à–∏–±–∫—É
///
///–ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–¥–µ–ª–∞—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º, –∫–æ—Ç–æ—Ä—ã–π –≤—ã—á–∏—Å–ª—è–µ—Ç –ø–æ–±–µ–¥–∏—Ç–µ–ª—è, 0 –∏–ª–∏ —Ö —Å—Ç–æ—è—Ç –≤ —Ä—è–¥–æ–∫

struct Cell1 {
    var x : Int
    var y : Int
    var object: Sign
}

enum Sign: String {
    case x = "‚ùå"
    case o = "üîò"
    case free = "‚¨ú"
}


struct XO {
    var width = 3
    var wide = 3
        
    var pole : [Cell1] = []
    
    //  –º–µ—Ç–æ–¥ —Å–æ–∑–¥–∞–Ω–∏—è –ø—É—Å—Ç–æ–≥–æ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
    mutating func createGame () {
        for w1 in 1...width {
            for w2 in 1...wide {
                pole.append(Cell1(x: w1, y: w2, object: .free))
            }
        }
    }
    
    // —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
    func checkWin (string: inout String) {
        if (pole[0].object == .x && pole[3].object == .x && pole[6].object == .x) || (pole[0].object == .x && pole[1].object == .x && pole[2].object == .x) || (pole[4].object == .x && pole[8].object == .x && pole[6].object == .x) || (pole[3].object == .x && pole[4].object == .x && pole[5].object == .x) || (pole[6].object == .x && pole[7].object == .x && pole[8].object == .x) || (pole[1].object == .x && pole[4].object == .x && pole[7].object == .x) || (pole[2].object == .x && pole[5].object == .x && pole[8].object == .x)  {
            string = "‚ùå‚ùå‚ùå‚ùå‚ùå‚ùå‚ùå‚ùå‚ùå"
        } else if (pole[0].object == .o && pole[3].object == .o && pole[6].object == .o) || (pole[0].object == .o && pole[1].object == .o && pole[2].object == .o) || (pole[4].object == .o && pole[8].object == .o && pole[6].object == .o) || (pole[3].object == .o && pole[4].object == .o && pole[5].object == .o) || (pole[6].object == .o && pole[7].object == .o && pole[8].object == .o) || (pole[1].object == .o && pole[4].object == .o && pole[7].object == .o) || (pole[2].object == .o && pole[5].object == .o && pole[8].object == .o) {
            string = "üîòüîòüîòüîòüîòüîòüîòüîòüîò"
            
        }
    }



    // –º–µ—Ç–æ–¥ —Ä–∞—Å–ø–µ—á–∞—Ç—ã–≤–∞–Ω–∏—è –ø–æ–ª—è
    mutating func printGame () {
        var tempString = ""
        
        for element in pole {
            switch element.object {
            case .free: tempString.append(element.object.rawValue)
            case .o: tempString.append(element.object.rawValue)
            case .x: tempString.append(element.object.rawValue)
            }
        }
        checkWin (string: &tempString)
        Swift.print( String(tempString.enumerated().map { $0 > 0 && $0 % 3 == 0 ? ["\n", $1] : [$1]}.joined()) )
    }
    
    // —Å–∞–±—Å–∫—Ä–∏–ø—Ç –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É –º–æ–∂–Ω–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ñ–∏–≥—É—Ä—É –≤ —è—á–µ–π–∫–µ –∏ –Ω–∞–∑–Ω–∞—á–∏—Ç—å —è—á–µ–π–∫–µ –Ω–æ–≤—É—é —Ñ–∏–≥—É—Ä—É
    subscript (coor1: Int, coor2: Int) -> Sign? {
        get {
            for element in pole {
                if element.x == coor1 && element.y == coor2 {
                    return element.object
                }
            }
            return nil
        }
        set {
            for element in 0..<pole.count {
                if pole[element].x == coor1 && pole[element].y == coor2 {
                    pole[element].object = pole[element].object == .free ? newValue! : pole[element].object
                    
                }
            }
        }
    }
    
    
        
} // –∫–æ–Ω–µ—Ü —Ç–∏–ø–∞ –∏–≥—Ä—ã –∫—Ä–µ—Å—Ç–∏–∫–∏ –Ω–æ–ª–∏–∫–∏

var game = XO()

game.createGame()
game.pole
game[1, 1]
game[1, 1] = .x
game[1, 2] = .o
game[2, 2] = .x
game[3, 3] = .o
game[2, 1] = .x
game[2, 3] = .o
game[3, 1] = .x

//game.printGame()





/// —Ç—è–∂–µ–ª—ã–π —É—Ä–æ–≤–µ–Ω—å —Å–ª–æ–∂–Ω–æ—Å—Ç–∏: –º–æ—Ä—Å–∫–æ–π –±–æ–π
/// —Å–¥–µ–ª–∞—Ç—å –∫–æ—Ä–∞–±–ª—å —Å–æ —Å–≤–æ–µ–π —Å–∏—Å—Ç–µ–º–æ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç, —à–∏—Ä–∏–Ω–∞ 1, + –≤—ã—Å–æ—Ç–∞
/// –ª–æ–∫–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç , –∫–æ—Ä–∞–±–ª—å –¥–æ–ª–∂–µ–Ω —É–º–µ—Ç—å –≥–æ–≤–æ—Ä–∏—Ç—å –ø–æ–ø–∞–ª–æ –≤ –Ω–µ–≥–æ, –∏–ª–∏ –æ–Ω —É–±–∏—Ç –ª–∏

// —Ç–∏–ø: –∫–æ—Ä–∞–±–ª—å
class Sheep {
    let column : Int
    let raw : Int
    let size : Int
    
    var sheepHeals : Int {
        didSet {
            if sheepHeals > 0 {
                print ("–ø–æ–ø–∞–ª")
            } else {
                print ("—É–±–∏–ª")
            }
        }
    }
    
    var isHorisontal : Bool
    
    init (column: Int, raw: Int, size: Int, isHorisontal: Bool) {
        self.column = column
        self.raw = raw
        self.size = size
        self.isHorisontal = isHorisontal
        self.sheepHeals = size
    }
    
} // –∫–æ–Ω–µ—Ü —Ç–∏–ø–∞ –∫–æ—Ä–∞–±–ª—å



/// —Å–¥–µ–ª–∞—Ç—å –ø–æ–ª–µ –¥–ª—è –∏–≥—Ä—ã –≤ –º–æ—Ä—Å–∫–æ–π –±–æ–π —Å–æ —Å–≤–æ–µ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω–æ–π —Å–∏—Å—Ç–µ–º–æ–π
/// –µ—Å–ª–∏ –≤—ã—Å—Ç—Ä–µ–ª –º–∏–º–æ –ø–æ–ª—è ‚Äî —Ç–æ –Ω–µ–ª—å–∑—è


struct Square { // —Ç–∏–ø —è—á–µ–π–∫–∏ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
    let column : Int
    let raw : Int
    var pieceOfSheep : Int
    var isHereAShip = false
    var wasShoot = false
    var whichShip: Sheep? = nil
}// –∫–æ–Ω–µ—Ü —Ç–∏–ø–∞ —è—á–µ–π–∫–∏



struct SheepsWar { // —Ç–∏–ø –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è —Å —è—á–µ–π–∫–∞–º–∏
    let column = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    let raw = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    // –ø—É—Å—Ç–æ–µ –ø–æ–ª–µ –±–∏—Ç–≤—ã
    var battlefield : [Square] = []
    
    // —Å–æ–∑–¥–∞—Ç—å –ø—É—Å—Ç–æ–µ –ø–æ–ª–µ –±–∏—Ç–≤—ã
    mutating func create () {
        for c in raw {
            for r in column {
                battlefield.append(Square(column: c, raw: r, pieceOfSheep: 0))
            }
        }
        Swift.print ("–ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ —Å–æ–∑–¥–∞–Ω–æ")
    }
    
    // —Ñ—É–Ω–∫—Ü–∏—è –ø–µ—á–∞—Ç–∏ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
    mutating func print () {
        
        var tempString = ""
        
        for element in battlefield {
            
            switch element.pieceOfSheep {
            case _ where element.isHereAShip == true && element.pieceOfSheep == 1: tempString.append("üõ≥ ")
            case _ where element.isHereAShip == true && element.pieceOfSheep == 0: tempString.append("üí• ")
            case _ where element.isHereAShip == false && element.wasShoot == false: tempString.append("üåä ")
            case _ where element.isHereAShip == false && element.wasShoot == true: tempString.append("üí® ")
            default: break
            }
        }

        Swift.print( String(tempString.enumerated().map { $0 > 0 && $0 % 20 == 0 ? ["\n", $1] : [$1]}.joined()) )
        Swift.print("************")
        
    } // –∫–æ–Ω–µ—Ü —Ñ—É–Ω–∫—Ü–∏–∏ –ø–µ—á–∞—Ç–∏
    
    // —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–º–µ—â–µ–Ω–∏—è –∫–æ—Ä–∞–±–ª—è –Ω–∞ –ø–æ–ª–µ (–≤ –º–∞—Å—Å–∏–≤ –ø–æ–ª—è)
    mutating func placeSheep (sheep: Sheep) -> () {
        
        // –¥–æ–ø —Ñ—É–Ω–∫—Ü–∏—è ‚Äî —Ä–∞—Å–ø–æ–ª–æ–∂–∏—Ç—å —á–∞—Å—Ç—å –∫–æ—Ä–∞–±–ª—è –Ω–∞ –æ–¥–Ω–æ–π —è—á–µ–π–∫–µ
        func placeOneSquare (_ sheepColumn: Int, _ sheepraw: Int, _ sheep1: Sheep?) {
            for square in 0..<battlefield.count {
                if sheepColumn == battlefield[square].column && sheepraw == battlefield[square].raw {
                    battlefield[square].pieceOfSheep = 1
                    battlefield[square].isHereAShip = true
                    battlefield[square].whichShip = sheep1
                }
            }
        }

        switch sheep {
        case _ where sheep.size == 1:
            placeOneSquare(sheep.column, sheep.raw, sheep)
        case _ where sheep.size == 2 && sheep.isHorisontal == true:
            placeOneSquare(sheep.column, sheep.raw, sheep)
            placeOneSquare(sheep.column, sheep.raw + 1,sheep)
        case _ where sheep.size == 2 && sheep.isHorisontal == false:
            placeOneSquare(sheep.column, sheep.raw, sheep)
            placeOneSquare(sheep.column + 1, sheep.raw, sheep)
        case _ where sheep.size == 3 && sheep.isHorisontal == true:
            placeOneSquare(sheep.column, sheep.raw, sheep)
            placeOneSquare(sheep.column, sheep.raw + 1, sheep)
            placeOneSquare(sheep.column, sheep.raw + 2, sheep)
        case _ where sheep.size == 3 && sheep.isHorisontal == false:
            placeOneSquare(sheep.column, sheep.raw, sheep)
            placeOneSquare(sheep.column + 1, sheep.raw, sheep)
            placeOneSquare(sheep.column + 2, sheep.raw, sheep)
        case _ where sheep.size == 4 && sheep.isHorisontal == true:
            placeOneSquare(sheep.column, sheep.raw, sheep)
            placeOneSquare(sheep.column, sheep.raw + 1, sheep)
            placeOneSquare(sheep.column, sheep.raw + 2, sheep)
            placeOneSquare(sheep.column, sheep.raw + 3, sheep)
        case _ where sheep.size == 4 && sheep.isHorisontal == false:
            placeOneSquare(sheep.column, sheep.raw, sheep)
            placeOneSquare(sheep.column + 1, sheep.raw, sheep)
            placeOneSquare(sheep.column + 2, sheep.raw, sheep)
            placeOneSquare(sheep.column + 3, sheep.raw, sheep)
        default: break
        }
        
    } // –∫–æ–Ω–µ—Ü —Ñ—É–Ω–∫—Ü–∏–∏ placeSheep
    
    
    // —Ñ—É–Ω–∫—Ü–∏—è –≤—ã—Å—Ç—Ä–µ–ª–∞ –ø–æ –∫–æ—Ä–∞–±–ª—é
    mutating func shoot (column: Int, raw: Int) {
        
        for element in 0..<battlefield.count {
            if battlefield[element].column == column && battlefield[element].raw == raw {
                switch battlefield[element] {
                case _ where battlefield[element].isHereAShip == false && battlefield[element].wasShoot == false:
                    battlefield[element].wasShoot = true
                case _ where battlefield[element].isHereAShip == false && battlefield[element].wasShoot == true:
                    Swift.print("shoot already was done")
                case _ where battlefield[element].isHereAShip == true && battlefield[element].pieceOfSheep == 1:
                    battlefield[element].pieceOfSheep = 0
                    battlefield[element].whichShip?.sheepHeals -= 1
                case _ where battlefield[element].isHereAShip == true && battlefield[element].pieceOfSheep == 0:
                    Swift.print("shoot already was done")
                default: break
                }
            }
        }
    } // –∫–æ–Ω–µ—Ü —Ñ—É–Ω–∫—Ü–∏–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞ –ø–æ –∫–æ—Ä–∞–±–ª—é
        
    
} // –∫–æ–Ω–µ—Ü —Ç–∏–ø–∞ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è


// —Å–æ–∑–¥–∞—é –∏–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ
var swGame = SheepsWar()
swGame.create()
swGame.print()

// —Å–æ–∑–¥–∞—é –∏ —Ä–∞—Å–ø–æ–ª–∞–≥–∞—é –∫–æ—Ä–∞–±–ª–∏
var ship4 = Sheep(column: 10, raw: 1, size: 4, isHorisontal: true)
swGame.placeSheep(sheep: ship4)
var ship3 = Sheep(column: 9, raw: 1, size: 3, isHorisontal: true)
swGame.placeSheep(sheep: ship3)
var ship2 = Sheep(column: 8, raw: 1, size: 2, isHorisontal: true)
swGame.placeSheep(sheep: ship2)
var ship1 = Sheep(column: 7, raw: 1, size: 1, isHorisontal: true)
swGame.placeSheep(sheep: ship1)

swGame.print()

// —Å—Ç—Ä–µ–ª—è—é –º–∏–º–æ
swGame.shoot(column: 3, raw: 3)
swGame.print()

// —Å—Ç—Ä–µ–ª—è—é –≤ –∫–æ—Ä–∞–±–ª—å
swGame.shoot(column: 7, raw: 1)
swGame.print()

swGame.shoot(column: 10, raw: 4)
swGame.print()
